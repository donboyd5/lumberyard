---
title: "Cambridge Lumberyard analysis"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_notebook: 
    df_print: paged
    fig_height: 6
    fig_width: 8
    toc: yes
    number_sections: yes
    code_folding: hide
editor_options:
  chunk_output_type: console
---

# SETUP SECTION

```{r setup, eval=TRUE, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}

# note that eval=TRUE unless set to FALSE
# to have a chunk's output show in the html file, set include=TRUE in the chunk's options

knitr::opts_chunk$set(eval=TRUE, include=FALSE, echo=FALSE, message=FALSE, rows.print=20)
options(width = 150)
```

```{r libraries}
library(tidyverse)
tprint <- 50  # default tibble print
options(tibble.print_max = tprint, tibble.print_min = tprint) # show up to tprint rows

# tools
library(vroom)
library(readxl)
library(lubridate)
library(RColorBrewer)
library(RcppRoll)
library(fredr)
library(btools)
library(tidycensus)

# graphics
library(scales)
library(ggbeeswarm)
library(patchwork)
library(gridExtra)
library(ggrepel)
library(ggbreak)

# tables
library(knitr)
library(kableExtra)
library(DT)
library(gt)

# maps
library(maps)
# https://cran.r-project.org/web/packages/usmap/vignettes/mapping.html
library(usmap)

```

```{r locations}
# dsacs <- r"(E:\data\CA_sacs/)"
# dsacs_all <- paste0(dsacs, "data/allyears/")
# 
# dj90 <- r"(E:\data\CA_j90/)"
# dj90_all <- paste0(dj90, "data/allyears/")

```


```{r functions_utility}
str_detect_any <- function(s, elements){
  # check whether each item in the string vector s
  # has at least one item in the string vector elements
  
  # get a list: one "row" per item in s
  #   each row is a logical vector with same length as elements
  logical_list <- purrr::map(s, stringr::str_detect, elements)
  
  # are any of the items in each "row" of the list true?
  purrr::map_lgl(logical_list, any)
  
  # test with the following code:
    # s <- c("str one", "str two", "str 3", "str 4", "my 8")
    # elements <- c("one", "3", "str", "7")
    # 
    # str_detect_any(s, elements)
  }


#..regex notes ----
# str_extract(ulabel, '![^!]+$'),  # everything after last !
#  "^[^,]+"  # everything before first ,
# x <- c("abc, def", "hijklm ,zyz")  str_extract(x, "^[^,]+")

```


```{r constants}
#.. geoids of interest ----
cambridge_town <- "3611511836"
cambridge_village <- "3611825"
cambridge_schools <- "3606210"
greenwich_town <- "3611530686"
greenwich_village <- "3630675"
greenwich_schools <- "3612900"
washington_county <- "36115"
newyork_state <- "36"

#.. api keys ----
source("~/R_projects/api_keys.r", verbose=TRUE)
fredr_set_key(fred_apikey)
## Not run: 
# census_api_key(census_apikey, install = TRUE)
# First time, reload your environment so you can use the key without restarting R.
# readRenviron("~/.Renviron")
# Sys.getenv("CENSUS_API_KEY")  # check

#.. graph theme items ----
legend_none <- theme(legend.position = "None")
legend_notitle <- theme(legend.title = element_blank())
caption_left <- theme(plot.caption = element_text(hjust = 0))

#.. source notes ----
acs_source <- "American Community Survey 5-year summary file"

```

```{r geos_dataframe}
geos <- read_delim(
"geotype;geoid;geoname

state; 36; New York

county; 36001; Albany County, New York
county; 36091; Saratoga County, New York
county; 36113; Warren County, New York
county; 36115; Washington County, New York

cosub; 36115; Washington County, New York

place; 3602550; Argyle village, New York
place; 3611825; Cambridge village, New York
place; 3630675; Greenwich village, New York
place; 3664771; Salem village, New York
place; 3665750; Schuylerville village, New York

school; 3603210; Argyle Central School District, New York
school; 3606210; Cambridge Central School District, New York
school; 3612900; Greenwich Central School District, New York
school; 3625470; Salem Central School District, New York
school; 3625770; Saratoga Springs City School District, New York
school; 3626160; Schuylerville Central School District, New York

zcta; 12816; 12816
zcta; 12834; 12834

", col_types=cols(.default = col_character()), trim_ws=TRUE
)
geos
```


# GOALS

The goal is to understand the current local housing situation and help inform decisions about what kind of housing might be appropriate to consider within the Lumber Yard.

I think the big questions are: • What does the census and other publicly available records tell us about the population and housing within Village of Cambridge (and perhaps the CCS school district catchment area of White Creek, Cambridge and Jackson and how they compare to prior censuses to see what the trends are?.\
• What is the current status of housing in Village of Cambridge?\
• What is needed or might be the right mix of housing options in the Village of Cambridge, generally to ensure a vibrant, dynamic, diverse, multi-generational caring rural community?\
• Are there case studies/lessons learned from other ' housing developments' that attract younger people (25-35 year olds) and entrepreneurs and remote workers to rural communities?

# DATA PREPARATION SECTION

```{r acs_notes}
# https://www.census.gov/programs-surveys/acs/data/summary-file.2019.html

```

```{r tidycensus_notes}
# https://walker-data.com/tidycensus/articles/basic-usage.html 
# load_variables() takes two required arguments: year of Census or endyear of ACS sample, and dataset name
# For decennial Census, possible dataset choices include "pl" for the redistricting files (currently the only choice for 2020), "sf1" or "sf2" (2000 and 2010) and "sf3" or "sf4" (2000 only)
#  For ACS, use either "acs1" or "acs5" for the ACS detailed tables, and append /profile for the Data Profile and /subject for the Subject Tables.

# 5-year ACS for all geographies down to the block group level starting with 2005-2009

#.. get_acs and geography ----
# https://walker-data.com/tidycensus/articles/basic-usage.html#working-with-acs-data-1
# geography="county subdivision", state="NY", county="Washington", # gets all in county
# geography="place", state="NY", # DON'T USE COUNTY, gets all in state
# geography="school district (unified)", state="NY", # DON'T USE COUNTY, gets all
# geography="zcta", state="NY", zcta=c(12816, 12834) # DON'T USE COUNTY, gets all

# keep_geo_vars=TRUE doesn't seem to matter for what I'm doing

```

```{r tidycensus_nonacs}
# median age by state in 2010
age10 <- get_decennial(geography = "state", 
                       variables = "P013001", 
                       year = 2010)

get_estimates(
  geography="county",
  product = "characteristics",
  # variables = NULL,
  breakdown = "AGEGROUP",
  state="NY",
  county="Washington",
  time_series = TRUE)

tpop <- get_estimates(
  geography="county subdivision",
  product = "characteristics",
  # variables = NULL,
  breakdown = "AGEGROUP",
  state="NY",
  county="Washington",
  time_series = TRUE)

```


```{r tidycensus_functions}

get_acstab <- function(acstab, years, dict=uvacs, geos=geos){
  
  get_geo <- function(geotype, year, acstab){
    print(geotype)
    if(geotype=="state"){
      df <- get_acs(geography="state",
                    state=states,
                    table=acstab,
                    year=year)
      } else if(geotype=="county") {
        df <- get_acs(geography="county",
                      state=states,
                      county=counties,
                      table=acstab,
                      year=year)
       } else if(geotype=="cosub"){
          df <- get_acs(geography="county subdivision",
                        state=cosubs_state,
                        county=cosubs_county,
                        table=acstab,
                   year=year)
        } else if(geotype=="place"){
          df <- get_acs(geography="place",
                   state=states,
                   table=acstab,
                   year=year)
        } else if(geotype=="school"){
          df <- get_acs(geography="school district (unified)",
                   state=states,
                   table=acstab,
                   year=year)
        } else if (geotype=="zcta" & year > 2009) {
          df <- get_acs(geography="zcta",
                        state="NY",
                        zcta=zctas,
                        table=acstab,
                        year=year)
          
        } else {
          df <- tibble(GEOID=NA_character_,
                       NAME=NA_character_,
                       variable=NA_character_,
                       estimate=NA_real_,
                       moe=NA_real_)
        }
        
        df <- df %>%
          setNames(str_to_lower(names(.))) %>%
          mutate(geotype=!!geotype,
                 year=!!year)  %>%
          select(geotype, year, geoid, geoname=name, variable, estimate, moe)
        
        df <- df %>%
          # drop non-cosub govts that are not specified in the geos file (revisit)
          left_join(geos %>% 
              select(geoid, geotype, geos_geoname=geoname) %>%
              mutate(ingeo=TRUE),
            by=c("geoid", "geotype")) %>%
          filter((geotype=="cosub") | ingeo) %>%
          select(-ingeo)
        return(df)
        }
  
  get_year <- function(year, acstab, geos){
    # the main program -- direct action for a single year
    print(year)
    if(acstab %in% tabs_avail$tableid[tabs_avail$year==year]) {
      map_dfr(geotypes, get_geo, year, acstab)
    } else {
      tibble(geo=NULL,
                  geoid=NULL,
                  name=NULL,
                  variable=NULL,
                  estimate=NULL,
                  moe=NULL)
    }
  }
  
  # these variables are available throughout the function
  geotypes <- unique(geos$geotype)
  states <- geos %>% filter(geotype=="state") %>% .$geoid
  counties <- geos %>% 
    filter(geotype=="county") %>% 
    mutate(counties=str_sub(geoid, 3, 5)) %>%
    .$counties
  places <- geos %>% filter(geotype=="place") %>% .$geoid
  cosubs <- geos %>% filter(geotype=="cosub") %>% .$geoid
  cosubs_state <- str_sub(cosubs, 1, 2)
  cosubs_county <- ifelse(nchar(cosubs)==5, str_sub(cosubs, 3, 5), NULL)
  zctas <- geos %>% filter(geotype=="zcta") %>% .$geoid
  
  tabs_avail <- count(dict, tableid, year=endyear)
  df <- map_dfr(years, get_year, acstab, geos)
  df
}

# tmp <- get_acstab(acstab="B25071", years=c(2009, 2014, 2019), dict=uvacs, geos=geos)

```

```{r ONETIME_tidycensus_uvacs}
# build a full variable list and clean it up so that it has uniform titles
vacs2009 <- load_variables(2009, "acs5", cache = TRUE)
vacs2014 <- load_variables(2014, "acs5", cache = TRUE)
vacs2018 <- load_variables(2018, "acs5", cache = TRUE)
vacs2019 <- load_variables(2019, "acs5", cache = TRUE)
vacs <- 
  bind_rows(vacs2009 %>% mutate(endyear=2009),
            vacs2014 %>% mutate(endyear=2014),
            vacs2018 %>% mutate(endyear=2018),
            vacs2019 %>% mutate(endyear=2019))

# create uniform labels based on latest year and count # years
uvacs <- vacs %>%
  separate(name, c("tableid", "vnum"), remove=FALSE) %>%
  group_by(name) %>%
  arrange(endyear) %>%
  mutate(nyears=n(), ulabel=label[endyear==max(endyear)], maxyear=max(endyear)) %>%
  ungroup %>%
  # there are never more than 8 parts to the uniform lable
  separate(ulabel, into=paste0("ulab", 1:8), sep="!!", remove=FALSE)

saveRDS(uvacs, here::here("data", "uvacs.rds"))

```


```{r tidycensus_table_selection}
# https://data.census.gov/cedsci/table
# ACS_2019_SF_5YR_Appendices.xlsx sheet Appendics A
# ACS2019_Table_Shells.xlsx

uvacs <- readRDS(here::here("data", "uvacs.rds"))

# possible concepts of interest
# AGE BY DISABILITY STATUS BY HEALTH INSURANCE COVERAGE STATUS
# AGE BY IMPUTATION OF INDEPENDENT LIVING DIFFICULTY FOR THE CIVILIAN NONINSTITUTIONALIZED POPULATION 15 YEARS AND OVER
# AGE BY NUMBER OF DISABILITIES
# AGE BY PRESENCE OF A COMPUTER AND TYPES OF INTERNET SUBSCRIPTION IN HOUSEHOLD
# AGE BY VETERAN STATUS BY EMPLOYMENT STATUS FOR THE CIVILIAN POPULATION 18 TO 64 YEARS
# AGE OF HOUSEHOLDER BY GROSS RENT AS A PERCENTAGE OF HOUSEHOLD INCOME IN THE PAST 12 MONTHS

tabs <- count(uvacs, tableid, concept)

s <- "educational attain"
s <- "geographical mobility"
s <- "percent of"
s <- "rent"
s <- "age"
(look <- tabs %>% 
  # filter(str_sub(tableid, 1, 1)=="B") %>%
  filter(str_detect(concept, coll(s, ignore_case = TRUE))) %>% select(tableid, concept))


# if needed:
df <- get_acs(geography="county",
            state="NY",
            # county=c("115"),
            table="B25071",
            year=2019)

```

```{r tidycensus_save_individual_tables}

# Universe if NOT Population 25 years and over in the United States (from table shell) is listed below
# B01001 SEX BY AGE
# total population
# B01002   MEDIAN AGE BY SEX
# Universe: Total population
# B07001    GEOGRAPHICAL MOBILITY IN THE PAST YEAR BY AGE FOR CURRENT RESIDENCE IN THE UNITED STATES
# Universe:  Population 1 year and over in the United States
# B07009 GEOGRAPHICAL MOBILITY IN THE PAST YEAR BY EDUCATIONAL ATTAINMENT FOR CURRENT RESIDENCE IN THE UNITED STATES
# B07409   GEOGRAPHICAL MOBILITY IN THE PAST YEAR BY EDUCATIONAL ATTAINMENT FOR RESIDENCE 1 YEAR AGO IN THE UNITED STATES
# B15003   EDUCATIONAL ATTAINMENT FOR THE POPULATION 25 YEARS AND OVER
# B25071  MEDIAN GROSS RENT AS A PERCENTAGE OF HOUSEHOLD INCOME IN THE PAST 12 MONTHS (DOLLARS)
# Universe:  Renter-occupied housing units paying cash rent

save_table <- function(tab){
  # print(tab)
  df <- get_acstab(acstab=tab, years=c(2009, 2014, 2019), dict=uvacs, geos=geos)
  df <- df %>% mutate(tableid=tab)
  fn <- paste0("tab_", tab, ".rds")
  saveRDS(df, here::here("data", fn))
  df
}

# get tables one at a time depending on exploration above
df <- save_table("B01001")
df <- save_table("B01002")
df <- save_table("B07001")
df <- save_table("B07009")
# df <- readRDS(here::here("data", "tab_B07009.rds"))
df <- save_table("B07409")
df <- save_table("B15003")
df <- save_table("B25071")


```


```{r tidycensus_combine_save}

# tmp <- get_acstab(acstab="B25071", years=c(2009, 2014, 2019), dict=uvacs, geos=geos)
# combine tables ----
combine_tabs <- function(tabnames){
  get_tab <- function(tabname){
    fname <- paste0("tab_", tabname, ".rds")
    df <- readRDS(here::here("data", fname))
    df
  }
  # get all the tabs
  df <- map_dfr(tabnames, get_tab)
  # clean them up
  df <- df %>%
    filter(!is.na(variable)) %>%
    select(-geos_geoname)%>%
    left_join(uvacs %>% 
                filter(endyear==maxyear) %>%
                select(variable=name, vnum, concept, starts_with("ulab")),
              by="variable") %>%
    mutate(concept=str_to_sentence(concept),
           across(ulab1:ulab8, ~ str_remove(.x, ":")),
           sname=str_extract(geoname, "^[^,]+"),
           sname=case_when(geoid=="36" ~ "New York State",
                           str_detect(sname, "ZCTA") ~ str_replace(sname, "ZCTA5", "Zip"),
                           TRUE ~ sname),
           sname=ifelse(sname %in% c("Salem village", "Salem CDP"),
                        "Salem village/CDP",
                        sname)) %>%
    select(geotype, geoid, sname, variable, tableid, vnum, year, estimate, moe,
           concept, ulab1:ulab8, ulabel, geoname) %>%
    arrange(geotype, geoid, variable, year)
}

# tabnames <- c("B01002", "B07001", "B07009", "B07409", "B15003", "B25071")
(tabfiles <- list.files(here::here("data"), pattern="tab_"))
tabnames <- tabfiles %>% str_remove("tab_") %>% str_remove(".rds")
acsdata <- combine_tabs(tabnames)
glimpse(acsdata)
count(acsdata, tableid)
count(acsdata, sname)
saveRDS(acsdata, here::here("data", "acsdata.rds"))

```


# DATA ANALYSIS
```{r load_data}
uvacs <- readRDS(here::here("data", "uvacs.rds"))
acsdata <- readRDS(here::here("data", "acsdata.rds"))

count(acsdata, tableid, concept)

```


# Population in and around the Village of Cambridge

## Age
### Median age
```{r median_age}

# geokeeps <- c(newyork_state, washington_county, cambridge_village, greenwich_village, cambridge_town, greenwich_town)
geokeeps <- c(newyork_state, washington_county, cambridge_village, greenwich_village)
pdata <- acsdata %>%
  filter(tableid=="B01002", 
         vnum=="001",
         geoid %in% geokeeps) %>%
  select(geotype, geoid, sname, variable, year, estimate, moe, concept) %>%
  mutate(geoid=factor(geoid, levels=geokeeps),
         order=as.integer(geoid),
         sname=fct_reorder(sname, order, min)) %>% # order we want
  arrange(sname, year)

# capt1 <- paste0("Note: Costs above 30 percent are generally often defined as burdensome. Smaller geographic areas generally have a larger margin of error.")
capt <- paste0("Source: ", acs_source, ".")
# capt <- paste0(capt1, "\n", capt2)

p <- pdata %>%
  ggplot(aes(x=reorder(sname, order), y=estimate, fill=as.factor(year))) +
  geom_col(position=position_dodge()) +
  # scale_fill_brewer(palette = "Paired") +
  scale_fill_manual(values=c('#e0f3db','#a8ddb5','#43a2ca')) +
  theme_bw() +
  labs(x=NULL,
       y=NULL,
       caption=capt) +
  ggtitle(label=str_to_sentence("Median age, selected areas"),
          subtitle = NULL) +
  # theme(axis.text.y = element_text(hjust = 0)) +
  # scale_x_continuous(breaks=seq(0, 100, 1), labels=label_comma(accuracy=.1), limits=xlims) +
  legend_notitle +
  caption_left
p

# p + scale_y_break(c(0, 30))

ggsave(here::here("results", "fig_median_age_bars.png"), plot=p, width=10, height=8, scale=1)
write_csv(pdata, here::here("results", "fig_median_age_bars_data.csv"))

```

### Age breakdown
```{r fig_pop_pyramid}
geokeeps <- c(newyork_state, washington_county, cambridge_village, greenwich_village)
# geokeeps <- c(newyork_state, washington_county, cambridge_village, greenwich_village,
#               cambridge_town, greenwich_town)

# vnum values for age groups - vnums for female low, high, then male
# agegroups <- read_csv(
# "agegroup, agelabel, flow, fhigh, mlow, mhigh
# 0, total, 26, 26, 2, 2
# 1, <= 17, 27, 30, 3, 6
# 2, 18 to <= 24, 31, 34, 7, 10
# 3, 25 to <= 34, 35, 36, 11, 12
# 4, 35 to <= 64, 37, 43, 13, 19
# 5, 65 to <= 84, 44, 48, 20, 24
# 6, >=85, 49, 49, 25, 25")


# finer groups
agegroups <- read_csv(
"agegroup, agelabel, flow, fhigh, mlow, mhigh
0, total, 26, 26, 2, 2
1, <= 17, 27, 30, 3, 6
2, 18 to <= 24, 31, 34, 7, 10
3, 25 to <= 34, 35, 36, 11, 12
4, 35 to <= 44, 37, 38, 13, 14
5, 45 to <= 64, 39, 43, 15, 19
5, 65 to <= 84, 44, 48, 20, 24
6, >=85, 49, 49, 25, 25")


vals <- function(low, high) {
  tibble(vnum=str_pad(low:high, width = 3, side = "left", pad = "0"))
}

agegroups_long <- agegroups %>%
  pivot_longer(-c(agegroup, agelabel)) %>%
  mutate(sex=str_sub(name, 1, 1),
         type=str_sub(name, 2, -1)) %>%
  select(-name) %>%
  pivot_wider(names_from = type) %>%
  mutate(sex=factor(sex, levels=c("m", "f"), labels=c("male", "female"))) %>%
  group_by(agegroup, agelabel, sex) %>%
  summarise(vals(low, high), .groups="drop")

acsdata %>%
  filter(tableid=="B01001") %>%
  count(ulab4, ulab3, vnum) 

basedata <- acsdata %>%
  filter(tableid=="B01001",
         geoid %in% geokeeps) %>%
  select(geotype, geoid, sname, variable, year, estimate, moe, concept, 
         vnum, ulab3, ulab4, ulabel) %>%
  left_join(agegroups_long, by="vnum") %>%
  filter(!is.na(sex)) %>%
  group_by(geotype, geoid, sname, sex, agegroup, agelabel, year) %>%
  summarise(estimate=sum(estimate), .groups="drop") %>%
  # now get pct share of area total population
  group_by(geotype, geoid, sname, year) %>%
  mutate(share=estimate / estimate[agegroup==0]) %>%
  ungroup

basedata %>%
  filter(geoid==cambridge_village, year==2019)

pdata <- basedata %>%
  filter(year==2019, agegroup!=0) %>%  # geoid %in% c(cambridge_village, greenwich_village), 
  mutate(geoid=factor(geoid, levels=geokeeps),
         order=as.integer(geoid),
         sname=fct_reorder(sname, order, min),
         pshare=ifelse(sex=="male", -share, share)) %>% # order we want
  arrange(sname, year)

clrs_br <- c("blue", "red")
clrs <- c('#ef8a62', '#67a9cf') %>% rev()
brks <- seq(-1, 1, .1)
brk_labs <- percent(abs(brks), accuracy=.1)
p <- pdata %>%
  ggplot(aes(x=pshare,
             y=reorder(agelabel, agegroup),
             fill = sex)) + 
  geom_bar(stat = "identity") +
  scale_x_continuous(name="% of the area's total population", breaks=brks,
                     labels = percent(abs(brks), accuracy=.1)) +
  scale_y_discrete(name=NULL) +
  scale_fill_manual(values=clrs) +
  theme_bw() +
  legend_notitle +
  ggtitle("Population share by age group") +
  facet_wrap(~ sname, ncol = 2)
  # theme(axis.text.x = element_text(angle = 90, hjust = 1))

p

ggsave(here::here("results", "fig_pop_pyramid.png"), plot=p, width=10, height=8, scale=1)
write_csv(pdata, here::here("results", "fig_pop_pyramid_data.csv"))

```


## Educational attainment

## Geographic mobility

## Population growth





# Housing in and around the Village of Cambridge
## Housing affordability
```{r plot_median_rent_income}
excludes <- c("Argyle", "Fort", "Dresden", "Hampton", "Hebron", "Whitehall", "Putnam", "Granville", "Kingsb", "Hartf")

pdata <- acsdata %>%
  filter(tableid=="B25071", year==2019, !str_detect_any(sname, excludes)) %>%
  mutate(cambvillage=geoid==cambridge_village)

capt1 <- paste0("Note: Costs above 30 percent are generally often defined as burdensome. Smaller geographic areas generally have a larger margin of error.")
capt2 <- paste0("Source: ", acs_source, ", 2015-2019.")
capt <- paste0(capt1, "\n", capt2)
# xlab <- "% of household income\n<--- more affordable : less affordable --->"
xlab <- "% of household income"

xlims <- c(22.25, 31.5)
p <- pdata %>%
  ggplot(aes(x=estimate, y=reorder(sname, estimate))) +
  # geom_errorbar(aes(xmin=pmax(estimate - moe, xlims[1]),
  #                   xmax=pmin(estimate + moe, xlims[2])),
  #               width=.05, colour="grey") +
  geom_point(aes(colour=cambvillage), size=3) +
  scale_colour_manual(values=c("blue", "red")) +
  # geom_col(fill="blue", size=2.5, width=0.3) +
  geom_vline(xintercept = 30, linetype="solid", colour="darkgrey", size=.5) +
  theme_bw() +
  labs(x=xlab,
       y=NULL,
       caption=capt) +
  ggtitle(label=str_to_sentence("MEDIAN GROSS RENT AS A PERCENTAGE OF HOUSEHOLD INCOME, 2015-2019 average"),
          subtitle = NULL) +
  # theme(axis.text.y = element_text(hjust = 0)) +
  scale_x_continuous(breaks=seq(0, 100, 1), labels=label_comma(accuracy=.1), limits=xlims) +
  legend_none +
  caption_left
p

ggsave(here::here("results", "fig_rent_affordability_2019.png"), plot=p, width=10, height=8, scale=1)
write_csv(pdata, here::here("results", "fig_rent_affordability_2019_data.csv"))

```


# Older

```{r census_geo}
gdir <- r"(E:\data\acs\sf\2019_5year\)"
fn <- "5_year_Mini_Geo.xlsx"

rgeo1 <- read_excel(paste0(gdir, fn), sheet="ny")

rgeo2 <- rgeo1 %>%
  setNames(c("stabbr", "logrecno", "geoid", "geoname")) %>%
  mutate(geoleft=str_sub(geoid, 1, 5),
         geomid=str_sub(geoid, 6, 7),
         georight=str_sub(geoid, 8, nchar(geoid)))
count(rgeo2, geoleft) %>% ht
count(rgeo2, geomid) %>% ht
count(rgeo2, georight) %>% ht

rgeo3 <- rgeo2 %>%
  select(stabbr, logrecno, geoid, geoname, geotype=geoleft, geonums=georight)

# which are the uniques?
rgeo3 %>%
  group_by(geotype) %>%
  mutate(n=n()) %>%
  ungroup %>%
  filter(n==1)

# geonums that start with something other than 36 are...
rgeoxpart <- rgeo3 %>%
  filter(!str_detect(geoname, "part"),
         !str_detect(geoname, "Remainder"))
count(rgeoxpart, geotype)

tmp <- rgeo3 %>%
  group_by(geotype) %>%
  mutate(n=n()) %>%
  ungroup %>%
  arrange(geotype, geoid)

# logrecno geoid     geoname                                                               geoty
# <chr>    <chr>     <chr>                                                                 <chr>
# 0000001  04000US36 New York                                                              04000
# 0000002  04001US36 New York -- Urban                                                     04001
# 0000003  04043US36 New York -- Rural                                                     04043
# 0000004  040A0US36 New York -- In metropolitan or micropolitan statistical area          040A0
# 0000005  040C0US36 New York -- In metropolitan statistical area                          040C0
# 0000006  040C1US36 New York -- In metropolitan statistical area -- in principal city     040C1
# 0000007  040C2US36 New York -- In metropolitan statistical area -- not in principal city 040C2
# 0000008  040E0US36 New York -- In micropolitan statistical area                          040E0
# 0000009  040E1US36 New York -- In micropolitan statistical area -- in principal city     040E1
# 0000010  040E2US36 New York -- In micropolitan statistical area -- not in principal city 040E2
# 0000011  040G0US36 New York -- Not in metropolitan or micropolitan statistical area      040G0
# 0000012  040H0US36 New York -- Not in metropolitan statistical area                      040H0

# we'll want geotypes
# 04000, 04001, 04043
# 05000 counties (5 nyc)
# 06000 cities, towns, villages, CDPs


rgcounty <- rgeo3 %>%
  filter(geotype=="05000")


gdf <- read_csv(paste0(gdir, "ny/", "g20195ny.csv"),
                col_names = FALSE)


```

```{r census_txt}
dir <- r"(E:\data\acs\sf\2019_5year\ny\)"
fn <- "e20195ny.txt"

# FILEID File Identification 6 Characters
# FILETYPE File Type 6 Characters
# STUSAB State/U.S.-Abbreviation (USPS) 2 Characters
# CHARITER Character Iteration 3 Characters
# SEQUENCE Sequence Number 4 Characters
# LOGRECNO Logical Record Number 7 Characters
idvars <- c("fileid", "filetype", "stusab", "chariter", "sequence", "logrecno")

rdf <- vroom(paste0(dir, fn), col_names=FALSE, 
             col_types = cols("c", "c", "c", "c", "c", "c",
                              .default= col_double()))
# rdf <- read_csv(paste0(dir, fn))
glimpse(rdf[, 1:7])
names(rdf)

# xvars <- paste0("x", 1:(ncol(rdf) - length(idvars)))
# vnames <- c(idvars, xvars)
names(rdf)[1:length(idvars)] <- idvars
glimpse(rdf)
names(rdf) <- str_to_lower(names(rdf))

saveRDS(rdf, paste0(dir, "e20195ny.rds"))

rdf <- readRDS(paste0(dir, "e20195ny.rds"))
glimpse(rdf[, 1:10])

tmp <- rdf %>%
  filter(sequence=="0001") %>%
  select(1:x55)

```

```{r census_reporter}
# https://censusreporter.org/profiles/16000US3611825-cambridge-ny/

```

```{r cornell}
# https://pad.human.cornell.edu/profiles/Washington.pdf


```

# WHY DO YOUNG PEOPLE COME TO A RURAL AREA?

# HOW DO IMPORTANT CHARACTERISTICS OF THE CAMBRIDGE AREA COMPARE AND CHANGE OVER TIME?
